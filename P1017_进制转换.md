# P1017 进制转换

## 题目描述

我们可以用这样的方式来表示一个十进制数: 将每个阿拉伯数字乘以一个以该数字所处位置的(值减11)为指数,以1010为底数的幂之和的形式。

与之相似的,对二进制数来说,也可表示成每个二进制数码乘以一个以该数字所处位置的(值-1−1)为指数,以22为底数的幂之和的形式。一般说来,任何一个正整数R或一个负整数-R都可以被选来作为一个数制系统的基数。如果是以R或-R为基数,则需要用到的数码为 0,1,..R−1。例如,当R=7时,所需用到的数码是0,1,2,3,4,5和6,这与其是R−R无关。如果作为基数的数绝对值超过1010,则为了表示这些数码,通常使用英文字母来表示那些大于99的数码。例如对1616进制数来说,用AA表示1010,用B*B*表示1111,用CC表示1212,用DD表示1313,用EE表示1414,用FF表示1515。

设计一个程序,读入一个十进制数和一个负进制数的基数, 并将此十进制数转换为此负进制下的数:-R∈{-2,-3,-4,...,-20}

## 输入输出格式

输入格式：



输入的每行有两个输入数据。

第一个是十进制数N*N* (-32768 \le N \le 32767−32768≤*N*≤32767)
第二个是负进制数的基数-R−*R*。



输出格式：



结果显示在屏幕上，相对于输入，应输出此负进制数及其基数，若此基数超过1010，则参照1616进制的方式处理。



## 输入输出样例

输入样例#1：



复制

```
30000 -2
```

输出样例#1：



复制

```
30000=11011010101110000(base-2)
```

输入样例#2：



复制

```
-20000 -2
```

输出样例#2：



复制

```
-20000=1111011000100000(base-2)
```

输入样例#3：



复制

```
28800 -16
```

输出样例#3：



复制

```
28800=19180(base-16)
```

输入样例#4：



复制

```
-25000 -16
```

输出样例#4：



复制

```
-25000=7FB8(base-16)
```

## 题解

```c++
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cmath>
using namespace std;
char z[20]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J'};
void change(int num, int base){
	if(num==0){
		return;
	}
	if(num%base<0){
		change(num/base+1,base);
		printf("%c",z[num%base-base]);
	}else{
		change(num/base,base);
		printf("%c",z[num%base]);
	}
}

int main(){
	int num,base;
	cin>>num>>base;
	printf("%d=",num);
	change(num,base);
	cout<<"(base"<<base<<")"<<endl;
	return 0;
}
```

### 分析

在程序语言中余数可能为负，但由于短除法要求，余数必须为正，所以当余数为负数时，商+1的同时余数-基数（基数为负）

### 相关知识点补充

1. 负数取余，通过取模来判定

   |小| % |大| = |小| 符号同前    |大| % |小| = |余| 符号同前

   3%4 = 3 ； -3%4 = -3 ； -3%-4 = -3 ； 3%-4 = 3；

   5%3 = 2 ； 5%-3 = 2  ；-5%-3 = -2 ； -5%3 = -2；

   ---------------------
   作者：MISAYAONE
   来源：CSDN
   原文：https://blog.csdn.net/misayaaaaa/article/details/69802746
   版权声明：本文为博主原创文章，转载请附上博文链接！

2. 短除的原理
   假设有一个二进制数 abcd，其中每个字母代表一个 0 或 1 。我们假设这个数等于十进制数 12 吧。那么我们要怎么计算 a、b、c、d 到底是 0 还是 1 呢？

   按照第一节中数的意义，将 abcd 从二进制转换成十进制，那么会得到：

   (abcd)2==a×23+b×22+c×21+d×20(12)10
   (abcd)2=a×23+b×22+c×21+d×20=(12)10
   于是我们得到了一个等式：

   a×23+b×22+c×21+d×20=12
   a×23+b×22+c×21+d×20=12
   不过这是个一元四次方程，似乎并不能得到唯一解……

   但是实际上我们忽略了两个重要的约束条件：

   a、b、c、d 都是正整数。
   它们不是 0 就是 1。
   别小看这点条件，它们的作用可是顶得上两个等式的！

   首先观察一下上述等式，我们发现，除了 d 之外，a、b、c 都有共同的系数 2，于是我们就可以对前三项进行因式分解：

   2×(22a+21b+c)+d=12
   2×(22a+21b+c)+d=12
   我们将括号内的内容看成一个整体，就叫 kk 吧，不难证明 kk 是个正整数，于是式子就简化成：

   2k+d=12
   2k+d=12
   而我们知道 d 不是 0 就是 1，kk 又是正整数，那么这个式子不就等价于：

   12÷2=k…d
   12÷2=k…d
   是吧？d 就是 12 除以 2 的余数，显然 d 就是 0 了！（因为 d 是 1 的话 k 就不可能是整数）那么 k 就是 6，即：

   22a+21b+c=6
   22a+21b+c=6
   这个式子很熟悉是不是，除了最后一项，前几项都有公共系数 2，于是我们又可以按照前面的套路进行因式分解：

   2(2a+b)+c=6
   2(2a+b)+c=6
   于是我们可以用与前面完全相同的方式处理，得到：

   6÷2=(2a+b)…c
   6÷2=(2a+b)…c
   于是就得出 c 是 0，2a+b2a+b 是 3 。
   ---------------------
   作者：Zhaosiyii
   来源：CSDN
   原文：https://blog.csdn.net/Zhaosiyii/article/details/55823883
   版权声明：本文为博主原创文章，转载请附上博文链接！

3.   正整数的取余运算大家都很熟悉，但是对于负数、实数的取余运算，确实给人很新鲜的感觉。于是我对


   此进行了一些探索。我发现，这里面还是颇有一点可以探索的东西的。


   自然数的取模运算的定义是这样的（定义1）：


   如果a和d是两个自然数，d非零，可以证明存在两个唯一的整数 q 和 r，满足 a = qd + r 且0 ≤ r < d


   。其中，q 被称为商，r 被称为余数。


   那么对于负数，是否可以沿用这样的定义呢？我们发现，假如我们按照正数求余的规则求 (-7) mod 3


   的结果，就可以表示 -7 为 (-3)* 3 +2。其中，2是余数，-3是商。


   那么，各种编程语言和计算器是否是按照这样理解的呢？下面是几种软件中对此的理解。


   C++（G++ 编译）： cout << (-7) % 3; // 输出 -1


   Java（1.6）： System.out.println((-7) % 3); // 输出 -1


   Python 2.6：>>>  (-7) % 3 // 输出 2


   百度计算器：(-7) mod 3 = 2


   Google 计算器：(-7) mod 3 = 2


   有道计算器：(-7) mod 3 = -1可以看到，结果特别有意思。这个问题是百家争鸣的。看来我们不能直


   接把正数的法则加在负数上。实际上，在整数范围内，自然数的求余法则并不被很多人所接受，大家大


   多认可的是下面的这个定义2。
   如果a 与d 是整数，d 非零，那么余数 r 满足这样的关系：


   a = qd + r , q 为整数，且0 ≤ |r| < |d|。


   可以看到，这个定义导致了有负数的求余并不是我们想象的那么简单，比如，-1 和 2 都是 (-7) mod 3


   正确的结果，因为这两个数都符合定义。这种情况下，对于取模运算，可能有两个数都可以符合要求。


   **我们把 -1 和 2 分别叫做正余数和负余数。通常，当除以d 时，如果正余数为r1，负余数为r2，那么有**


   **r1 = r2 + d**


   对负数余数不明确的定义可能导致严重的计算问题，对于处理关键任务的系统，错误的选择会导致严重


   的后果。


   看完了 (-7) mod 3，下面我们来看一看 7 mod (-3) 的情况（看清楚，前面是 7 带负号，现在是 3 带


   负号）。根据定义2，7 = (-3) * (-2) + 1 或7 = (-3) * (-3) -2，所以余数为 1 或 -2。


   C++（G++ 编译）： cout << 7 % (-3); // 输出 1


   Java（1.6）： System.out.println(7 % (-3)); // 输出 1


   Python 2.6：>>>  输出 -2


   百度计算器：7 mod (-3) = -2


   Google 计算器： 7 mod (-3) = -2


   有道计算器：不支持
   从中我们看到几个很有意思的现象：
   Java 紧随 C++ 的步伐，而 Python、Google、百度步调一致。难道真是物以类聚？联想一下，


   Google 一直支持 Python，Python 也颇有 Web 特色的感觉，而且 Google Application Engine 也


   用的 Python，国内的搜索引擎也不约而同地按照 Google 的定义进行运算。
   可以推断，C++ 和 Java 通常会尽量让商更大一些。比如在 (-7) mod 3中，他们以 -2 为商，余数为


   -1。在 Python 和 Google 计算器中，尽量让商更小，所以以 -3 为商。在 7 mod (-3) 中效果相同：


   C++ 选择了 3 作为商，Python 选择了 2 作为商。但是在正整数运算中，所有语言和计算器都遵循了


   尽量让商小的原则，因此 7 mod 3 结果为 1 不存在争议，不会有人说它的余数是-2。
   如果按照第二点的推断，我们测试一下 (-7) mod (-3)，结果应该是前一组语言（C++，Java）返回 2


   ，后一组返回 -1。（请注意这只是假设）
   于是我做了实际测试：


   C++（G++ 编译）： cout << (-7) % (-3); // 输出 -1


   Java（1.6）： System.out.println((-7) % (-3)); // 输出 -1


   Python 2.6：>>>  输出 -1


   百度计算器：-7 mod (-3) = -1


   Google 计算器： -7 mod (-3) = -1


   结果让人大跌眼镜，所有语言和计算机返回结果完全一致。


   总结时间到
   我们由此可以总结出下面两个结论：
   **对于任何同号的两个整数，其取余结果没有争议，所有语言的运算原则都是使商尽可能小。**
   **对于异号的两个整数，C++/Java语言的原则是使商尽可能大，很多新型语言和网页计算器的原则是使**


   **商尽可能小。**
   最后是拓展时间。对于实数，我们也可以定义取模运算（定义3）。
   当a 和 d 是实数，且d 非零, a 除以 d 会得到另一个实数（商），没有所谓的剩余的数。但如果要求商


   为一个整数，则余数的概念还是有必要的。可以证明：存在唯一的整数商 q 和唯一的实数 r 使得: a =


   qd + r, 0 ≤ r < |d|.（转自维基百科）
   如上在实数范围内扩展余数的定义在数学理论中并不重要，尽管如此，很多程序语言都实现了这个定义
