# 算约数

## 题目描述

科学家们在Samuel星球上的探险得到了丰富的能源储备，这使得空间站中大型计算机“Samuel II”的长时间运算成为了可能。由于在去年一年的辛苦工作取得了不错的成绩，小联被允许用“Samuel II”进行数学研究。

小联最近在研究和约数有关的问题，他统计每个正数N的约数的个数，并以f(N)来表示。例如12的约数有1、2、3、4、6、12。因此f(12)=6。下表给出了一些f(N)的取值：

![img](https://cdn.luogu.org/upload/pic/1645.png)

f(n)表示n的约数个数，现在给出n，要求求出f(1)到f(n)的总和。

## 输入输出格式

输入格式：



输入一行，一个整数n



输出格式：



输出一个整数，表示总和



## 输入输出样例

输入样例#1：



复制

```
3
```

输出样例#1：



复制

```
5
```

## 说明

【数据范围】

20%N<=5000

100%N<=1000000

## 题解

- 数学方法思路：

其实，我一开始就是用数学方法过的，毕竟就8行代码

重点在于一个公式：

# **f(i)=n/i**

至于公式是怎么推出来的，看我解释：

1-n的因子个数，可以看成共含有2因子的数的个数+含有3因子的数的个数……+含有n因子的数的个数

但在1~n中含有“2”这个因子的数有n/2个，3有n/3个，以此类推，公式就出来了

接下来就是代码了（我觉得代码就不用加注释了吧，第6行就是公式的循环写法）

- 数学方法代码：

```c++
#include<iostream>
using namespace std;
int n,ans;
int main(void){
    cin>>n;
    for(int i=1;i<=n;i++)ans+=n/i;
    cout<<ans;
}
```

### 优化

```c++
#include<cstdio>
int n,ans;
int main(){
    scanf("%d",&n);
    for(int i=1,j;i<=n;i=j+1){
        j=n/(n/i);
        ans+=(n/i)*(j-i+1);
    }
    printf("%d",ans);
return 0;
}
```

> 当n越来越大时，n/i的值相等的概率就越高，此时通过跳过中间n/i相等的部分就达到了优化，利用m/k得到的值q总是能使qk>m-1且q是当qk<m/k时的**最大值**原理。
